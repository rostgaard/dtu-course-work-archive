\documentclass[10pt]{scrartcl}
\usepackage{geometry}
\usepackage[parfill]{parskip}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{color}
\usepackage{listings}
\lstset{
  frame=single,language=bash,
  morekeywords={od, in, foreach, let, end, and, or, proc, while},
   basicstyle=\footnotesize,
  escapechar=\@,
  basicstyle=\footnotesize, frame=tb,
  numbers=left,
  stepnumber=2,
  numbersep=5pt, 
  numberstyle=\tiny\color{mygray},
  xleftmargin=.2\textwidth, xrightmargin=.2\textwidth
}
\usepackage{geometry}
 \geometry{
 a4paper,
 total={210mm,297mm},
 left=20mm,
 right=20mm,
 top=20mm,
 bottom=20mm,
 }
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}
\definecolor{mygray}{rgb}{0.2,0.2,0.2}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\title{02257 - Applied functional programming}
\subtitle{Project 2 - Drawing trees}
\author{Anna Maria Walach - \textit {s121540@student.dtu.dk} \\ Kim Rostgaard Christensen - \textit {s084283@student.dtu.dk}}
\begin{document}
\maketitle
\section{Translating solution to F\#}
\section{Generating PostScript file}
Generation of PostScript content, is a matter of mapping nodes to PostScript commands. In our case we have found that the following macro works well.
\begin{lstlisting}[language=PostScript]
$node_x $node_y            moveto
($label)                   dup stringwidth pop 2 div neg 0 rmoveto show
$node_x $padded_node_y     moveto
$parent_x $parent_y        lineto stroke
\end{lstlisting}
the \$ denotes values generated in the F\# program. This block adds a centered label and draws a line from a child node to its parent.
We generate the drawing top-down, as the algorithm from \cite{kennedy1996functional} already handled the tree fitting for us.

PostScript files contain both footers and headers that needs to be prepended and appended to the PostScript content -- respectively.
\section{Visualizing AST's}
\section{Efficiency}

Typical concatenation
Real: 00:00:00.001, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0\\
> Real: 00:00:00.008, CPU: 00:00:00.000, GC gen0: 1, gen1: 0, gen2: 0\\
Real: 00:00:00.009, CPU: 00:00:00.015, GC gen0: 2, gen1: 1, gen2: 1\\
> Real: 00:00:00.011, CPU: 00:00:00.015, GC gen0: 0, gen1: 0, gen2: 0\\
Real: 00:00:00.012, CPU: 00:00:00.015, GC gen0: 0, gen1: 0, gen2: 0\\
> Real: 00:00:00.009, CPU: 00:00:00.015, GC gen0: 1, gen1: 0, gen2: 0\\\\
StringBuilder concatenation
Real: 00:00:00.001, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0\\
> Real: 00:00:00.011, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0\\
Real: 00:00:00.005, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0\\
> Real: 00:00:00.007, CPU: 00:00:00.015, GC gen0: 1, gen1: 0, gen2: 0\\
Real: 00:00:00.005, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0\\
Real: 00:00:00.007, CPU: 00:00:00.015, GC gen0: 0, gen1: 0, gen2: 0\\\\
> String.concat concatenation
Real: 00:00:00.001, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0\\
Real: 00:00:00.012, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0\\
> Real: 00:00:00.005, CPU: 00:00:00.000, GC gen0: 0, gen1: 0, gen2: 0\\
Real: 00:00:00.007, CPU: 00:00:00.000, GC gen0: 1, gen1: 0, gen2: 0\\
> Real: 00:00:00.007, CPU: 00:00:00.000, GC gen0: 1, gen1: 0, gen2: 0\\
Real: 00:00:00.010, CPU: 00:00:00.000, GC gen0: 2, gen1: 0, gen2: 0\\
\section{Extensions}
\section{Conclusions}
We have not tested the limit on how big trees we can generate, but are clearly limited by not using tail recursion in our drawing algorithm. A nice improvement would be to make the algorithm tail recursive.

\bibliographystyle{plain}
\bibliography{references}

\end{document}  
