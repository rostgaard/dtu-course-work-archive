/*   Parser spec. for simple imperative language      mrh 03-01 2014 */
%{ 
open AST
%}

%token <int> INT
%token <bool> BOOL
%token <string> STRING
%token <string> NAME
%token TRUE FALSE
%token ASG SKIP SEMI WHILE DO OD CONTOF LET IN END PROC CALL REC RETURN IF THEN ELSE FI
%token FOREACH AND OR FOR
%token COLON COMMA PRINT PERIOD
%token LPAR RPAR LSQPAR RSQPAR
%token EOF

%start Main Exp ExpList DecList Stm StmList Dec
%type <Exp> Exp
%type <Exp list> ExpList
%type <Dec> Dec
%type <Dec list> DecList
%type <Stm list> StmList
%type <Stm> Main Stm

%left AND OR

%%

Main:
    Stm EOF                             { $1 }

Stm:
	NAME ASG Exp                        { Asg(Var $1,$3) }
  | NAME LSQPAR Exp RSQPAR ASG Exp      { ArrAsg($1, $3, $6) }
  | SKIP                                { Skip }
  | WHILE Exp DO StmList OD             { While($2,Seq $4) }
  | IF Exp THEN StmList ELSE StmList FI { IfElse ($2, Seq $4, Seq $6) }
  | IF Exp THEN StmList FI              { IfElse ($2, Seq $4, Seq [Skip]) }
  | LET DecList IN StmList END          { Block($2,Seq $4) }
  | PRINT Exp                           { PrintLn $2 }
  | CALL NAME LPAR ExpList RPAR         { Call ($2,$4)}
  | RETURN Exp                          { Return ($2)}
  | FOREACH NAME IN NAME DO StmList OD  { Foreach ($2, $4, Seq $6)}
  | FOR LPAR Stm SEMI Exp SEMI Stm RPAR DO StmList OD { For($3, $5, $7, Seq $10)}

StmList:
    Stm                                 { [$1] }
  | Stm SEMI StmList                    { $1 :: $3 } 

Dec: 
     NAME COLON Exp                        { VarDec($1,$3) }  
   | NAME LSQPAR Exp RSQPAR COLON Exp      { ArrDec($1,$3,$6)}
   | REC PROC NAME LPAR ParamList RPAR Stm { ProcDec($3,$5,$7)}
   | PROC NAME LPAR ParamList RPAR Stm     { ProcDec($2,$4,$6)}

ParamList:
                                        { []   }
   | NAME                               { [$1] }
   | NAME COMMA ParamList               { $1 :: $3 }

DecList:
                                        { [] } 
   | Dec                                { [$1] }
   | Dec SEMI DecList                   { $1 :: $3 }
   		    
Exp:
    NAME                                 { Var $1  }
  | INT                                  { Int $1 }
  | BOOL                                 { Bool $1 }
  | STRING                               { String $1}
  | NAME PERIOD NAME                     { Attribute ($1, $3)}
  | NAME LSQPAR Exp RSQPAR               { ArrVar ($1, $3) }
  | CONTOF Exp                           { ContOf $2 }        
  | LPAR Exp RPAR                        { $2 }
  | NAME LPAR ExpList RPAR               { Apply($1, $3) }
  | Exp AND Exp                          { AndOp($1, $3) }
  | Exp OR Exp                           { OrOp($1, $3) }

ExpList:
                                        { [ ] }
  | Exp                                 { [$1]   }
  | Exp COMMA ExpList                   { $1 :: $3 }  